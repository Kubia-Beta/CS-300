///////////////////////////
// By:                 ///
// Connor Sculthorpe  ///
// 13 April 2024     ///
///////////////////////

 /**
  * Time: O(1)
  * Space: O(n)
  */
struct Course { // Structure to hold course information
	int courseNumber;
	string courseTitle;
	vector<string> coursePrerequisites;
	
	Course(){ // Default constructor
		this->courseNumber = INT_MAX; // INT_MAX for debugging
	}
	Course(string title) : Course(){ // Constructor chain
		this->courseTitle = "";
	}
	Course(vector<string> prerequisites) : Course (string title) {
		this->vector<string> coursePrerequisites = prerequisites;
	}
	Course(int number, string title, vector<string> prerequisites) : Course(vector<string> prerequisites){
		this->courseNumber = number;
		this->courseTitle = title;
		this->coursePrerequisites = prerequisites;
	}
		bool operator<(const Course &leftCourse, const Course &rightCourse) { // Overload < operator for sorting
		return stoi(leftCourse.courseNumber) < stoi(rightCourse.courseNumber);
	}
}

 /**
  * Time: O(n)
  * Space: O(n)
  */
class BST {
	struct Node {
	Course course
	Node* left;
	Node* right;
	int height; // Field to store AVL implementation height association

	Node(){ // Default constructor
		left = nullptr;
		right = nullptr;
	}

	Node(Course aCourse) : Node() { // Call the default constructor when calling the constructor
		course = aCourse;
	}
}
	private:
		Node* root;
		void addNode(Node* node, Course aCourse);
		void InOrderHelper(Node* node);
		void PreOrderHelper(Node* node);
		void PostOrderHelper(Node* node);
		void DeconstructorHelper(Node* node);
		Node* removeNode(Node* node, int courseNumber);
		int TreeSize;
		void vectorPrinter(vector<string> Vector);
	
	public:
		BST();
		virtual ~BST();
		void InOrder();
		void PostOrder();
		void PreOrder();
		void Insert(Course aCourse);
		void Remove (int courseNumber);
		void Size();
		Course Search(int courseNumber);
		void CreateBSTFromFile(string file);
}

 /**
  * Adds a node with course to the tree
  * 
  * Time: O(log n)
  * Space: O(n)
  * @param Node* node to be referenced from
  * @param Course aCourse to be added
  */
void BST::addNode(Node* node, Course aCourse){
	if (node->course.courseNumber > aCourse.courseNumber){ // If the existing course number is greater than the one to be inserted
		if (node->left == nullptr) { // Left subtree has no lesser node
			node->left = new Node(aCourse); // Construct a new node and make it the left pointer of the current node
			this->TreeSize = this->TreeSize + 1; // Tree size has increased by one node
		}
		else { // Left not nullptr, exists
			addNode(node->left, aCourse); // Recurse leftward
		}
	}
	else { // Existing course number is less than the one to be inserted
		if (node->right == nullptr){ // Right subtree has no lesser node
			node->right = new Node(aCourse); // Construct a new node and make it the right pointer of the current node
			this->TreeSize = this->TreeSize + 1; // Tree size has increased by one node
		}
		else { // Right nmot nullptr, exists
			addNode(node->right, aCourse); // Recurse rightward
		}
	}
}

 /**
  * Passes root to the helper function to recursively traverse left, visit root, traverse right
  *
  * Time: O(n^2), θ(n log n)
  * Space: O(n)
  * @param Node* node to be displayed
  */
void BST::InOrder(){
	this->InOrderHelper(root);
}

 /**
  * Recursively traverse left, visit root, traverse right
  *
  * Time: O(n^2), θ(n log n)
  * Space: O(n)
  * @param Node* node to be displayed
  */
void BST::InOrderHelper(Node* node){
	if (node != nullptr) {
		InOrderHelper(node->left); // Recurse leftward to print all items before
		cout << node->course.courseNumber << ": " << node->course.courseTitle << " | ";
		vectorPrinter(node->course.coursePrerequisites);
		InOrderHelper(node->right); // Now recurse rightward now that we have printed all nodes to the left and the input node
	}
}

 /**
  * Passes root to the helper function to recursively visit root, traverse left, traverse right
  * Time: O(n^2), θ(n log n)
  * Space: O(n)
  */
void BST::PreOrder(){
	this->PreOrderHelper(root);
}

 /**
  * Recursively visit root, traverse left, traverse right
  *
  * Time: O(n^2), θ(n log n)
  * Space: O(n)
  * @param Node* node to be displayed
  */
void BST::PreOrderHelper(Node* node){ //FIXME: Add code comments to explain the algorithm, then add to all Order type
	if (node != nullptr){
		cout << node->course.courseNumber << ": " << node->course.courseTitle << " | ";
		vectorPrinter(node->course.coursePrerequisites);
		PreOrderHelper(node->left);
		PreOrderHelper(node->right);
	}
}

 /**
  * Passes root to the helper function to recursively traverse left, traverse right, visit root
  * Time: O(n^2), θ(n log n)
  * Space: O(n)
  */
void BST::PostOrder(){
	this->PostOrderHelper(root);
}

 /**
  * Recursively traverse left, traverse right, visit root
  *
  * Time: O(n^2), θ(n log n)
  * Space: O(n)
  * @param Node* node to be displayed
  */
void BST::PostOrderHelper(Node* node){
	if (node != nullptr){
		cout << node->course.courseNumber << ": " << node->course.courseTitle << " | ";
		vectorPrinter(node->course.coursePrerequisites);
		PostOrderHelper(node->left);
		PostOrderHelper(node->right);
	}
}

 /**
  * Default constructor
  * Time: O(1)
  * Space: O(1)
  */
BST::BST(){
	this->root = nullptr;
	this->TreeSize = 0;
}

 /**
  * Destructor
  * Time: O(n)
  * Space: O(n), θ(log n)
  */
virtual ~BST(){
	DeconstructorHelper(this->root);
}

 /**
  * Recursively deletes the nodes of a tree
  *
  * Time: O(n)
  * Space: O(n), θ(log n)
  * @param Node* node to be deleted
  */
void BST::DeconstructorHelper(Node* node){
	if(node != nullptr){
		DeconstructorHelper(node->left);
		DeconstructorHelper(node->right);
		delete node;
		node = nullptr;
		this->TreeSize = this->TreeSize - 1;
	}
}

 /**
  * Insert a course
  *
  * Time: O(log n)
  * Space: O(n)
  * @param int Course to be inserted
  */
void BST::Insert(Course aCourse){
	if (root == nullptr){ // Root does not exist
		root = new Node(aCourse); // Make the new node root
		this->TreeSize = this->TreeSize + 1;
	}
	else {
		addNode(&(this->root), course) // Add by passing the root as reference since node was not specified
	}
}

 /**
  * Recursively remove a course
  * Passes node information to removeNode(Node* node, int courseNumber).
  *
  * Time: O(n)
  * Space: O(n), θ(log n)
  * @param int courseNumber to be removed
  */
void BST::Remove (int courseNumber){
	this->removeNode(root, courseNumber); // Calls the helper function to remove the node
	cout << "Removed " + courseNumber << endl; // Outputs a message indicating the successful removal
	this->TreeSize = this->TreeSize - 1; // Decrements the size of the tree
	return;
}

 /**
  * Recursively remove a course from the tree
  *
  * Time: O(n)
  * Space: O(n), θ(log n)
  * @param Node* node to reference from
  * @param int Course to be removed
  */
Node* BinarySearchTree::removeNode(Node* node, int courseNumber) { 
	if (node == nullptr) { // If we have a blank for a node
		return nullptr; // Then do not try to remove it
	}

	if (node->course.courseNumber > course.courseNumber){ // If the existing course number is greater than the one to be removed
		node->left = removeNode(node->left, courseNumber); // Recurse down and replace the removed node
	}
	else if (node->course.courseNumber < course.courseNumber) { // Course for removal is larger, go right
		node->right = removeNode(node->right, courseNumber); // Recurse down and replace the removed node
	}
	else { // Match found
		if (node->left == nullptr && node->right == nullptr) { // leaf case
			delete node;
			node = nullptr; // Keep the pointer safe
			return nullptr;
		}
		else if (node->left != nullptr && node->right == nullptr) { // Right is null case ("Case 4")
			Node* temp = node;
			node = node->left;
			delete temp;
		}
		else if (node->left == nullptr && node->right != nullptr) { // Left is null case ("Case 3")
			Node* temp = node;
			node = node->right;
		}
		else { // Two children case ("Case 1")
			Node* temp = node->right;
			while (temp->left != nullptr) {  // Traverse left
				temp = temp->left;
			}
			node->course = temp->course;
			node->right = removeNode(node->right, temp->course.courseNumber); // Recursively remove successor since it was copied
		}
	}
	return node;
}

 /**
  * Searches a course from the tree
  *
  * Time: O(n)
  * Space: O(n)
  * @param int Course to be searched for
  */
Course BST::Search(int courseNumber){
	Node* currNode = this->root;

	while (currNode != nullptr) {
		int comparisonResult = currNode.courseNumber - courseNumber; // Compare the search courseNumber against the currently held courseNumber
		if (comparisonResult == 0) { // Found the course
			return currNode->course; // Return the currently held course that matched
		}
		else if (comparisonResult < 0) { // The check is less than what was checked against
			currNode = currNode->left; // Shift loop left
		}
		else { // current > courseNumber checked against
			currNode = currNode->right; // Shift loop right
		} // Continue looping
	} // Current is nullptr, match is not found

	Course course;
	return course;
}

 /**
  * Get the size of the current Binary Search Tree
  * Time: O(1)
  * Space: O(1)
  */
int BST::Size(){
	return this->TreeSize;
}

 /**
  * Prints a course's vector contents for prerequisites
  *
  * Time: O(n)
  * Space: O(1)
  * @param vector<string> Vector to be printed
  */
void BST::vectorPrinter(vector<string> Vector) {
	//FIXME: Make a cout or format for Order and Vector
	for (auto i: Vector){
		cout << i << ",";
	}
	cout << endl;
}

/**
  * Opens a file, reads its data, and parses each line and adds it to the Binary Search Tree
  *
  * Time: O(n)
  * Space: O(n)
  * @param string filename to be opened
  */
void BST::CreateBSTFromFile(string file) {
	string line = ""; // Holds each line read from file
	verifyFile(file);
	
	// Initialize our variables for holding course information
	vector<string> prerequisites;
	string number;
	string title;
	
	ifstream infile(file); // Open the file

	while (getline(file, line)){ // Read each line from the file
		istringstream iss(line);
		string token;
		int i = 0;
		
		while (getline(iss, token, ',')){ // Parse the line by commas, token holds the values
			i++ // Increase the line count by 1
			
			if (i > 2){ // Add the prerequisites to the vector after the first two commas
				prerequisites.push_back(token);
			} else if (i == 1){ // The first line ex. "CSCI100"
				number = token;
			} else if (i == 2){ // The second line ex. "Introduction to Computer Science"
				title = token;
			}
		} // The line has been fully read
		Course course(number, title, prerequisites); // Create a course object with the parsed data
		Insert(course); // Insert that course object into the tree
	} // Continues looping until all lines have been parsed into course in BST

		

	infile.close(); // Close the file
}


//============================================================================
// Static methods
//============================================================================


 /**
  * Verifies file and data integrity and validity of a course document. Returns specific errors about different file format issues.
  *
  * Time: O(n), where n is the number of lines in the file
  * Space: O(k), where k is the largest line in the file
  * @param string filename to be searched and verified
  * 
  * Code based on ony of my own public repositories, Hold_to_Craft
  * https://github.com/Kubia-Beta/Hold_to_Craft
  */
void verifyFile(string &filename){
	string line = ""; // Comparison string, starts as empty
	ifstream infile(filename) // Open the file
	regex fileFormatting("C.*\d+,\s*[A-Za-z].*") // REGEX: Catches C, then any characeters, then a digit, a comma, and then any letter
	try {
		if (!infile){ // could not open, failbit. We may not have access, or the file may not exist.
			throw runtime_error("File Access: Please verify the input file " + filename // Output what file went wrong with the error
			+ " exists and is not protected.");
		} else if (file.good == false){ // Other file operating issue
			throw runtime_error("Unknown File Access error on file " + filename + ".");
		}
		while(getline(infile, line)){ // While reading line by line
			int currLine = 1 // keep track of which line may throw an error for debugging

			if(line.find("CSC" != string::npos) || // Checks for common contents and compares them to "no position", throws error if they do not exist
			  (line.find("Intro" != string::npos) || // If all three equal npos, then none were found
			  (line.find("100" != string::npos) ||{ // In short, we check for these three markers for valid formatting line by line
				throw runtime_error("File Format: Error at line: " + currLine // Add the error line in the document to the error
					+ "Class names are of an incorrect format."
					+ " Expected type: CSCI100.");
				// Removed the extra check for being unnecessary algorithmically
			}
			// Since the substrings exist, check if they are in the expected order:
			else if(regex_match(line, fileFormatting) == false){ // Uses a regex to find any class, if we do not find it:
				throw runtime_error("Internal File Structure: error at line " + currLine // Add the error line in the document to the error
				+ ". Class naming convention is incorrect and could not be read."
				+ "Expected type: CSCI100,Introduction to Computer Science");
			}
			
			++currLine; // Increase the line counter each time while() finishes a loop
		} // To get to this line, the file must now be verified
		infile.close() // We are done verifying, close the file
		return
	}
	catch(){ // Something went wrong
		infile.close()
		cerr << "Error in file verification. Please check the console log."
		return
	}
}


void DataStructureChoicePrinter(int &curLoaded, string &file){
	take choice from main
	take file from main
	
	if (curLoaded is 1) {
		call vector print
	}
	if (curLoaded is 2) {
		call hash table print
	}
	if (curLoaded is 3) {
		call InOrder()
	}
	return;
}

void DataStructureChoiceFinder(int &curLoaded){
	take curLoaded from main
	int searchKey = 100
	
	if (curLoaded is 1) {
		call vector search
	}
	if (curLoaded is 2) {
		call hash table search
	}
	if (curLoaded is 3) {
		call Search(searchKey)
	
	return;
}

void DataStructureChoiceRemover(int &curLoaded){
	take curLoaded from main
	
	if (curLoaded is 1) {
		call vector remove
	}
	if (curLoaded is 2) {
		call hash table remove
	}
	if (curLoaded is 3) {
		call Remove(removeKey)
	
	return;
}


int main(int argc, char* argv[]) {
	string filename = "courses.txt";
	int choice = 0;
	int curLoaded = 0;
	clock_t ticks;
	
	while (choice != 9) {
		cout << "Menu:" << endl;
		cout << "1. Load Vector" << endl;
		cout << "2. Load Hash Table" << endl;
		cout << "3. Load Tree" << endl;
		cout << "4. Print loaded data" << endl;
		cout << "5. Find selected data" << endl;
		cout << "6. Remove selected data" << endl;
		cout << "9. Exit" << endl;
		cin >> choice;

		switch (choice) {

		case 1: // Load vector
			CreateVectorFromFile(file); // Load the vector
			curLoaded = 1; // Set flag for the vector as the loaded element
			break;

		case 2: // Load Hash Table
			CreateHashFromFile(file);
			curLoaded = 2;
			break;

		case 3: // Load Binary Search Tree
			call CreateBSTFromFile(file);
			curLoaded = 3;
			break;

		case 4: // Print loaded data
			DataStructureChoicePrinter(curLoaded);
			break;
			
		case 5: // Find data
			DataStructureChoiceFinder(curLoaded);
			break;
			
		case 6: // Remove data
			DataStructureChoiceRemover(curLoaded);
			break;
		}
	}
	cout << "Good bye." << endl;

	return 0;
}