# CS-300 : Connor Sculthorpe
Holds the contents of the CS-300-R4806 DSA: Analysis and Design 24EW4 class, including any code projects for it.

The final project is located [here](CS300%20Project%20Two/CS300%20Project%20Two.cpp), within the CS300 Project Two folder.

## What was the problem you were solving in the projects for this course?

In this course, my goal was to better understand data structures outside of a theoretical mathematical framework and take that layer of abstract knowledge and apply it to a problem. This meant that I needed to think not just in terms of algorithms and functions in mathematical terms, but also to see how those terms took shape within a programming language. This meant that I needed to learn to translate mathematical thoughts into programming thoughts to understand the translation scheme between them.

## How did you approach the problem? Consider why data structures are important to understand.

I approached the problem by trying to understand where mathematics ends, and programming begins within each assignment. This meant rereading parts of some of my textbooks to understand prior thinking and the thinking of experts within mathematics, then read that same subject written from a programmer’s perspective. This helped me understand how certain structures are conceptualized by programmers in contrast to mathematicians, where others in mathematics would not make a distinction between a linked list and a tree, such differences between like structures are incredibly important. As while one is a derivative structure of the other in math, they are entirely different in programming.

In fact, some of this knowledge from mathematics helped me understand why programmers classify entire like structures as different from one another, as from the perspective of a programmer, these structures are different. While I had seen the perspective before where certain linked lists had special insertion and traversal operations to form binary trees, I had not considered the practical application of how that impacts the structure of a program. I had taken for granted that these were all solved problems derived from mathematics and had not considered the impact of programming language’s layers of abstraction from the problems programmers were facing.

## How did you overcome any roadblocks you encountered while going through the activities or project?

Often when solving logic problems, you are not the first to try to solve that problem. Frequently, if textbooks cannot provide the answer in a way that helps me understand a problem, I would turn to trying to search for the problem through Google. I would try to find the generalized answer to a problem through video, as I know I tend to do better with lectures than written text. If I got particularly stuck, I would try to leave my computer for a few minutes to see if I could refresh my thinking by removing myself from the problem temporarily.

## How has your work on this project expanded your approach to designing software and developing programs?
	
 Part of doing this work has helped me understand why making custom data structures is often so rare within programming. There are multiple problems to solve for every implementation of each structure, and all of them are incredibly difficult to test as they depend upon one another, making testing them in pieces far more difficult than regular code and increasing the number of hours worked. I realized that I had not equipped myself with testing capabilities that matched the scope of the code I was writing, and that most of what I was solving with was approached from a theoretical framework rather than a practical one. So, I have resolved myself to better understand how to write tests as I progress more complicated pieces of code.

## How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

Parts of doing this work have informed my view on keeping data structures in separate files when it is not necessary to have them in one document. I would rather have six include statements which abstract the problems away from the document I am working on to make it easier to maintain and understand the problem at hand. Problems are already abstracted away from the programmer through the language being used and the methods already included, there is little to gain and much to lose by not continuing that practice.
