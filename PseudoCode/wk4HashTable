///////////////////////////
// By:                 ///
// Connor Sculthorpe  ///
// 13 April 2024     ///
///////////////////////

 /**
  * Time: O(1)
  * Space: O(n)
  */
struct Course { // Structure to hold course information
	string courseNumber;
	string courseTitle;
	vector<string> coursePrerequisites;
	
	Course(){ // Default constructor
		this->courseNumber = INT_MAX; // INT_MAX for debugging
	}
	Course(string title) : Course(){ // Constructor chain
		this->courseTitle = "";
	}
	Course(vector<string> prerequisites) : Course (string title) {
		this->vector<string> coursePrerequisites = prerequisites;
	}
	Course(string number, string title, vector<string> prerequisites) : Course(vector<string> prerequisites){
		this->courseNumber = number;
		this->courseTitle = title;
		this->coursePrerequisites = prerequisites;
	}
		bool operator<(const Course &leftCourse, const Course &rightCourse) { // Overload < operator for sorting
		return stoi(leftCourse.courseNumber) < stoi(rightCourse.courseNumber);
	}
}

 /**
  * Time: O(n)
  * Space: O(n)
  */
class HashTable {
	private:
		const unsigned int DEFAULT_SIZE = 97; // Largest 2 digit prime as a default constant
		
		struct Node {
			Course course
			unsigned int key
			Node* next;
	
			Node(){ // Default constructor
				key = UINT_MAX; // 0xFFFFFFFF
				next = nullptr;
			}
	
			Node(Course aCourse) : Node() { // Call the default constructor when calling the constructor
				course = aCourse;
			}
			
			Node(Course Course, unsigned int aKey) : course(aCourse), key(aKey), next(nullptr) { // Continue calling previous constructors
				key = aKey
			}
		}
		
		vector<Node> nodes;
		unsigned int tableSize = DEFAULT_SIZE;
		unsigned int Hash(int aKey);
		
	public:
		HashTable();
		HashTable(unsigned int size);
		~HashTable();
		bool IsEmpty() const;
		void InsertItem(Course course, string item);
		void RemoveItem(Course course);
		Course SearchHash(Course course);
		void PrintHash();
		void SortByCourseNumber();
}

/**
 * Default constructor for the HashTable class.
 *
 * Time: O(1)
 * Space: O(1)
 */
HashTable::HashTable() {
	nodes.resize(tableSize);
	for (Node& node : nodes) { // Initialize each node in the vector
		node = Node();
	}
}

/**
 * Constructor for the HashTable class.
 *
 * Time: O(n)
 * Space: O(n)
 * @param unsigned int size: The size of the hash table.
 */
HashTable::HashTable(unsigned int size) {
	this->tableSize = size;
	nodes.resize(tableSize);
}

/**
 * Destructor for the HashTable class.
 *
 * Time: O(n)
 * Space: O(1)
 */
HashTable::~HashTable(){
	// FIXME: Destructor
}

/**
 * Hash function to calculate the index for a given key.
 *
 * Time: O(1)
 * Space: O(1)
 * @param int aKey: The key to be hashed.
 * @return unsigned int: The hash value.
 */
int HashTable::Hash(int aKey) {
	return aKey % tableSize;
}

/**
 * Checks if the hash table is empty.
 *
 * Time: O(n)
 * Space: O(1)
 * @return bool: True if the hash table is empty, false otherwise.
 */
bool HashTable::IsEmpty(){
	for (const Node node : nodes) {
		if (node.key != UINT_MAX) {
			return false; // Non-empty slot found
		}
	}
	return true; // All slots are empty
}

/**
 * Inserts a new item into the hash table. If it collides, chain it.
 *
 * Time: O(n)
 * Space: O(1)
 * @param Course course: The course to be inserted.
 */
void HashTable::InsertItem(Course course) {
	unsigned key = Hash(course.courseNumber);
	Node* node = &(nodes.at(key));
	
	else if (node->key == UINT_MAX){ // Is empty
		node = Node(course, key);
	}
	else { // Chain
		while (node->next != nullptr) { // Traverse to find the end
			node = node->next;
		}
		node->next = new Node(course, key); // Add a new node to the end of chain
	}
}

/**
 * Removes an item from the hash table.
 *
 * Time: O(n)
 * Space: O(1)
 * @param Course course: The course to be removed.
 */
void HashTable::RemoveItem(Course course) {
	unsigned int key = Hash(course.courseNumber);
	Node* node = &(nodes[key]);
	
	
	if (node->course == course) { // Check if the first node matches the course
		nodes[key] = *(node->next); // Remove the first node by updating the pointer
		delete node;
		return;
	}
	
	while (node->next != nullptr) { // Search the chain for the course to remove
		if (node->next->course == course) {
			Node* temp = node->next;
			node->next = temp->next;
			delete temp;
			return;
		}
		node = node->next;
	}
}

/**
 * Searches for a course in the hash table.
 *
 * Time: O(n)
 * Space: O(1)
 * @param int aKey: The key of the course to be searched.
 * @return Course*: Pointer to the found course, or nullptr if not found.
 */
Course HashTable::SearchHash(int aKey) {
	unsigned int key = Hash(aKey);
	Node* node = &(nodes[key]);
	
	while (node != nullptr) { // Search the chain for the course
		if (node->key != UINT_MAX && node->course.courseNumber == aKey) {
			return &(node->course);
		}
		node = node->next;
	}
	return nullptr; // Course not found
}

/**
 * Prints the contents of the hash table.
 *
 * Time: O(n)
 * Space: O(n)
 */
void HashTable::PrintHash() {
	for (const Node& node : nodes) {
		Node* current = node.next; // Start from the first node in the chain
		while (current != nullptr) {
			cout << "Key: " << current->key << ", Course: " << current->course.courseNumber << endl;
			current = current->next; // Move to the next node in the chain
		}
	}
}

/**
  * Opens a file, reads its data, and parses each line and adds it to the Hash Table
  *
  * Time: O(n)
  * Space: O(n)
  * @param string filename to be opened
  */
void HashTable::CreateHashFromFile(string file) {
	string line = ""; // Holds each line read from file
	verifyFile(file);
	
	// Initialize our variables for holding course information
	vector<string> prerequisites;
	string number;
	string title;
	
	ifstream infile(file); // Open the file

	while (getline(file, line)){ // Read each line from the file
		istringstream iss(line);
		string token;
		int i = 0;
		
		while (getline(iss, token, ',')){ // Parse the line by commas, token holds the values
			i++ // Increase the line count by 1
			
			if (i > 2){ // Add the prerequisites to the vector after the first two commas
				prerequisites.push_back(token);
			} else if (i == 1){ // The first line ex. "CSCI100"
				number = token;
			} else if (i == 2){ // The second line ex. "Introduction to Computer Science"
				title = token;
			}
		} // The line has been fully read
		Course course(number, title, prerequisites); // Create a course object with the parsed data
		Insert(course); // FIXME: Insert for Hash Table
	} // Continues looping until all lines have been parsed into course in BST

		

	infile.close(); // Close the file
}


/**
  * Extract all courses from the hash table
  *
  * Time: O(N log N)
  * Space: O(1)
  * Reference: https://en.cppreference.com/w/cpp/algorithm/sort
  */
void HashTable::SortByCourseNumber() {
	vector<Course> tempCourses; // Create a temp vector to hold the course information while we sort it
	for (const Node& node : nodes) {
		Node* current = &node;
		while (current) {
			tempCourses.push_back(current->course);
			current = current->next;
		}
	}
	
	// Sort the extracted courses by course number using a lambda function
	sort(tempCourses.begin(), tempCourses.end(), [](const Course& a, const Course& b)) {
		return std::stoi(a.courseNumber) < std::stoi(b.courseNumber);
	});
	
	nodes.clear(); // Clear it now that we have a sorted vector to copy into it
	for (const Course& course : tempCourses) { // Reinsert sorted courses into the hash table
		InsertItem(course);
	}
}