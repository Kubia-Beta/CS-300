///////////////////////////
// By:                 ///
// Connor Sculthorpe  ///
// 13 April 2024     ///
///////////////////////

 /**
  * Time: O(1)
  * Space: O(n)
  */
struct Course { // Structure to hold course information
	int courseNumber;
	string courseTitle;
	vector<string> coursePrerequisites;
	
	Course(){ // Default constructor
		this->courseNumber = INT_MAX; // INT_MAX for debugging
	}
	Course(string title) : Course(){ // Constructor chain
		this->courseTitle = "";
	}
	Course(vector<string> prerequisites) : Course (string title) {
		this->vector<string> coursePrerequisites = prerequisites;
	}
	Course(int number, string title, vector<string> prerequisites) : Course(vector<string> prerequisites){
		this->courseNumber = number;
		this->courseTitle = title;
		this->coursePrerequisites = prerequisites;
	}
}

 /**
  * Time: O(n)
  * Space: O(n)
  */
class HashTable {
	private:
		const unsigned int DEFAULT_SIZE = 97; // Largest 2 digit prime as a default constant
		
		struct Node {
			Course course
			unsigned int key
			Node* next;
	
			Node(){ // Default constructor
				key = UINT_MAX; // 0xFFFFFFFF
				next = nullptr;
			}
	
			Node(Course aCourse) : Node() { // Call the default constructor when calling the constructor
				course = aCourse;
			}
			
			Node(Course Course, unsigned int aKey) : course(aCourse), key(aKey), next(nullptr) { // Continue calling previous constructors
				key = aKey
			}
		}
		
		vector<Node> nodes;
		unsigned int tableSize = DEFAULT_SIZE;
		unsigned int Hash(int aKey);
		
	public:
		HashTable();
		HashTable(unsigned int size);
		~HashTable();
		bool IsEmpty() const;
		void InsertItem(Course course, string item);
		void RemoveItem(Course course);
		Course SearchHash(Course course);
		void PrintHash();
}

/**
 * Default constructor for the HashTable class.
 *
 * Time: O(1)
 * Space: O(1)
 */
HashTable::HashTable() {
	nodes.resize(tableSize);
	for (Node& node : nodes) { // Initialize each node in the vector
		node = Node();
	}
}

/**
 * Constructor for the HashTable class.
 *
 * Time: O(n)
 * Space: O(n)
 * @param unsigned int size: The size of the hash table.
 */
HashTable::HashTable(unsigned int size) {
	this->tableSize = size;
	nodes.resize(tableSize);
}

/**
 * Destructor for the HashTable class.
 *
 * Time: O(n)
 * Space: O(1)
 */
HashTable::~HashTable(){
	// Node vector will deallocate itself when called here
}

/**
 * Hash function to calculate the index for a given key.
 *
 * Time: O(1)
 * Space: O(1)
 * @param int aKey: The key to be hashed.
 * @return unsigned int: The hash value.
 */
int HashTable::Hash(int aKey) {
	return aKey % tableSize;
}

/**
 * Checks if the hash table is empty.
 *
 * Time: O(n)
 * Space: O(1)
 * @return bool: True if the hash table is empty, false otherwise.
 */
bool HashTable::IsEmpty(){
	for (const Node node : nodes) {
		if (node.key != UINT_MAX) {
			return false; // Non-empty slot found
		}
	}
	return true; // All slots are empty
}

/**
 * Inserts a new item into the hash table.
 *
 * Time: O(n)
 * Space: O(1)
 * @param Course course: The course to be inserted.
 * @param string item: The item associated with the course.
 */
void HashTable::InsertItem(Course course, string item) {
	unsigned key = Hash(course.courseNumber);
	Node* node = &(nodes.at(key));

	if (node->key == UINT_MAX){ // Is empty
		node = Node(course, key);
	}
	else {
		while (node->next != nullptr) { // Traverse to find the end
			node= node->next;
		}
		node->next = new Node(course, key); // Add a new node to the end
	}
}

/**
 * Removes an item from the hash table.
 *
 * Time: O(n)
 * Space: O(1)
 * @param Course course: The course to be removed.
 */
void HashTable::RemoveItem(Course course) {
	unsigned int key = Hash(course.courseNumber);
	Node* node = &(nodes[key]);
	
	
	if (node->course == course) { // Check if the first node matches the course
		nodes[key] = *(node->next); // Remove the first node by updating the pointer
		delete node;
		return;
	}
	
	while (node->next != nullptr) { // Search the chain for the course to remove
		if (node->next->course == course) {
			Node* temp = node->next;
			node->next = temp->next;
			delete temp;
			return;
		}
		node = node->next;
	}
}

/**
 * Searches for a course in the hash table.
 *
 * Time: O(n)
 * Space: O(1)
 * @param int aKey: The key of the course to be searched.
 * @return Course*: Pointer to the found course, or nullptr if not found.
 */
Course HashTable::SearchHash(int aKey) {
	unsigned int key = Hash(aKey);
	Node* node = &(nodes[key]);
	
	while (node != nullptr) { // Search the chain for the course
		if (node->key != UINT_MAX && node->course.courseNumber == aKey) {
			return &(node->course);
		}
		node = node->next;
	}
	return nullptr; // Course not found
}

/**
 * Prints the contents of the hash table.
 *
 * Time: O(n)
 * Space: O(n)
 */
void HashTable::PrintHash() {
	for (const Node& node : nodes) {
		Node* current = node.next; // Start from the first node in the chain
		while (current != nullptr) {
			cout << "Key: " << current->key << ", Course: " << current->course.courseNumber << endl;
			current = current->next; // Move to the next node in the chain
		}
	}
}


// Code based on ony of my own public repositories, Hold_to_Craft
// https://github.com/Kubia-Beta/Hold_to_Craft
void verifyFile(string &filename){
	string inLine = "" // Now unused comparison string? Keep for now for version control?
	string line = ""
	ifstream infile(filename)
	regex fileFormatting("C.*\d+,\s*[A-Za-z].*") // Catches C, then any characeters, ends in a digit, comma, any letter
	try {
		if (!infile){ // could not open, failbit
			cerr << "error on file opening, make sure the program hass access to the directory" // Prints an error to the console
			throw runtime_error("File Access: Please verify the input file exists and is not protected")
		} else if (file.good == false){ // Other file operating issue
			throw runtime_error("Unknown File Access error")
		}
		while(getline(infile, line)){ // While reading line by line
			int i = 1
			if(line.find("CSC" || "Intro" || "100")  != string::npos) { // Do these common contents exist
				if(line.substr(line.find("CSC" || "Intro" || "100") + 1).empty()){ // If it does exist, does anything exist after it
					cerr << "Error in file formatting" // If not, we have a major problem
					throw runtime_error("File Format: Error in file formatting")
				}
			} else if(regex_match(line, fileFormatting) == false){ // File does not have the correct ordering of structure
				cerr << "Error in file structure at line: " + i // show expected format in error?
				throw runtime_error("Internal File Structure: error at line " + i)
			}
		} // To get to this line, it must now be verified
		infile.close() // We are done verifying, close the file
		return
	}
	catch(){
		infile.close()
		cerr << "Eror in file verification. Please check the console log."
		return
	}
}

// Open the file, read the data, parse each line
void openAndReadFile(string file, Vector<Course> courses) {
	string filename = file
	string line = "";
	verifyFile(filename)
	
	ifstream infile(filename)
	
	while (getline(infile, line)) {
		istringstream iss(line)
		string token
		vector<string> tokens
		
		while (getline(iss, token, ',')) {
			pushback(token)
		}
		
		for (token size) {
			coursePrerequisites.pushback(tokens[i])
		}
		Course course(number, title, prerequisites)
		courses.pushback(course)
	}
	
	infile.close()
}