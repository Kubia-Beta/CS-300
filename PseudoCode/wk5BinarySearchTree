struct Course { // Structure to hold course information
	int courseNumber;
	string courseTitle;
	vector<string> coursePrerequisites;
	Course(){
		courseNumber = INT_MAX; // INT_MAX for debugging
	}
}

class BST {
	struct Node {
	Course course
	Node* left;
	Node* right;

	Node(){ // Default constructor
		left = nullptr;
		right = nullptr;
	}

	Node(Course aCourse) : Node() { // Call the default constructor when calling the constructor
		course = aCourse;
	}
}
	private:
		Node* root;
		void addNode(Node* node, Course course);
		void InOrderHelper(Node* node);
		void PreOrderHelper(Node* node);
		void PostOrderHelper(Node* node);
		Node* removeNode(Node* node, int courseNumber);
		int TreeSize;
	
	public:
		BST();
		virtual ~BST();
		void InOrder();
		void PostOrder();
		void PreOrder();
		void Insert(Course course);
		void remove (int courseNumber);
		Course Search(int courseNumber);
}

// Adds a node with course to the tree
void BST::addNode(Node* node, Course course){
	if (node->course.courseNumber > course.courseNumber){ // If the existing course number is greater than the one to be inserted
		if (node->left == nullptr) { // Left subtree has no lesser node
			node->left = new Node(course); // Construct a new node and make it the left pointer of the current node
			this->TreeSize = this->TreeSize + 1; // Tree size has increased by one node
		}
		else { // Left not nullptr, exists
			addNode(node->left, course); // Recurse leftward
		}
	}
	else { // Existing course number is less than the one to be inserted
		if (node->right == nullptr){ // Right subtree has no lesser node
			node->right = new Node(course); // Construct a new node and make it the right pointer of the current node
			this->TreeSize = this->TreeSize + 1; // Tree size has increased by one node
		}
		else { // Right nmot nullptr, exists
			addNode(node->right, course); // Recurse rightward
		}
	}
}

// Passes root to the helper function
// Traverse left, visit root, traverse right (recursive)
void BST::InOrder(){
	this->InOrderHelper(root);
}

// Traverse left, visit root, traverse right (recursive)
void BST::InOrderHelper(Node* node){
	if (node != nullptr) {
		InOrderHelper(node->left); // Recurse leftward to print all items before
		cout << node->course.courseNumber << ": " << node->Course.courseTitle << " | "
		<< node.Course.coursePrerequisites << endl;
		InOrderHelper(node->right); // Now recurse rightward now that we have printed all nodes to the left and the input node
	}
}

// Passes root to the helper function
// Visit root, traverse left, traverse right (recursive)
void BST::PreOrder(){
	this->PreOrderHelper(root);
}

// Visit root, traverse left, traverse right (recursive)
void BST::PreOrderHelper(Node* node){
	if (node != nullptr){
		cout << node->course.courseNumber << ": " << node->Course.courseTitle << " | "
		<< node.Course.coursePrerequisites << endl;
		PreOrderHelper(node->left);
		PreOrderHelper(node->right);
	}
}

// Passes root to the helper function
// Traverse left, traverse right, visit root (recursive)
void BST::PostOrder(){
	this->PostOrderHelper(root);
}

// Traverse left, traverse right, visit root (recursive)
void BST::PostOrderHelper(Node* node){
	if (node != nullptr){
		cout << node->course.courseNumber << ": " << node->Course.courseTitle << " | "
		<< node.Course.coursePrerequisites << endl;
		PostOrderHelper(node->left);
		PostOrderHelper(node->right);
	}
}

// Default constructor
BST::BST(){
	this->root = nullptr;
	this->TreeSize = 0;
}

// Destructor
virtual ~BST(){
	deleteTree(this->root);
}

// Insert a course
void BST::Insert(Course course){
	if (root == nullptr){ // Root does not exist
		root = new Node(course); // Make the new node root
	}
	else {
		addNode(&(this->root), course) // Add by passing the root as reference since node was not specified
	}
}

// Remove a course
void BST::remove (int courseNumber){
	
}

// Find a course
Course BST::Search(int courseNumber){
	
}

// Get the size of the current Binary Search Tree
int BST::Size(){
	return this->TreeSize;
}

// Code based on ony of my own public repositories, Hold_to_Craft
// https://github.com/Kubia-Beta/Hold_to_Craft
void verifyFile(string &filename){
	string line = ""; // Comparison string, starts as empty
	ifstream infile(filename) // Open the file
	regex fileFormatting("C.*\d+,\s*[A-Za-z].*") // Catches C, then any characeters, ends in a digit, comma, any letter
	try {
		if (!infile){ // could not open, failbit. We may not have access, or the file may not exist.
			throw runtime_error("File Access: Please verify the input file " + filename // Output what file went wrong with the error
			+ " exists and is not protected.");
		} else if (file.good == false){ // Other file operating issue
			throw runtime_error("Unknown File Access error on file " + filename + ".");
		}
		while(getline(infile, line)){ // While reading line by line
			int currLine = 1 // keep track of which line may throw an error for debugging
			
			// Begin verifying each line of the document:
			// Target format: "CSCI100,Introduction to Computer Science"
			if(line.find("CSC" != string::npos) || // Checks for common contents and compares them to "no position"
			  (line.find("Intro" != string::npos) || // If all three equal npos, then none were found
			  (line.find("100" != string::npos) ||{ // In short, we check for these three markers for valid formatting line by line
				
				// Components exist, is the formatting consistent with "CSCI100"
				if(line.substr(line.find("CSC") + 1).empty()) || // Look ahead by 1 position after finding this string.
				line.substr(line.find("Intro")+ 1).empty() || // If anything is read after these terms,
				line.substr(line.find("100")+ 1).empty() { // then the file must be following the correct format.
					// If no characters are found in the position after search strings, then:
					throw runtime_error("File Format: Error at line: " + currLine // Add the error line in the document to the error
					+ "Class names are of an incorrect format."
					+ " Expected type: CSCI100.");
				}
				
			} else if(regex_match(line, fileFormatting) == false){ // Uses a regex to find any class, if we do not find it:
				throw runtime_error("Internal File Structure: error at line " + currLine // Add the error line in the document to the error
				+ ". Class naming convention is incorrect and could not be read."
				+ "Expected type: CSCI100,Introduction to Computer Science");
			}
			
			++currLine; // Increase the line counter each time while() finishes a loop
		} // To get to this line, it must now be verified
		infile.close() // We are done verifying, close the file
		return
	}
	catch(){ // Something went wrong
		infile.close()
		cerr << "Error in file verification. Please check the console log."
		return
	}
}

// Open the file, read the data, parse each line
void openAndReadFile(string file, Vector<Course> courses) {
	string line = "";
	verifyFile(file);
	
	ifstream infile(file);
	
	while (getline(infile, line)) {
		istringstream iss(line);
		string token;
		vector<string> tokens;
		
		while (getline(iss, token, ',')) {
			pushback(token);
		}
		
		for (token size) {
			coursePrerequisites.pushback(tokens[i]);
		}
		Course course(number, title, prerequisites);
		courses.pushback(course);
	}
	
	infile.close();
}