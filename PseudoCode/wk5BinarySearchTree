struct Course { // Structure to hold course information
	int courseNumber;
	string courseTitle;
	vector<string> coursePrerequisites;
	
	Course(){ // Default constructor
		this->courseNumber = INT_MAX; // INT_MAX for debugging
	}
	Course(string title) : Course(){ // Constructor chain
		this->courseTitle = "";
	}
	Course(vector<string> prerequisites) : Course (string title) {
		this->vector<string> coursePrerequisites;
	}
	Course(int number, string title, vector<string> prerequisites) : Course(vector<string> prerequisites){
		this->courseNumber = number;
		this->courseTitle = title;
		this->coursePrerequisites = prerequisites;
	}
}

class BST {
	struct Node {
	Course course
	Node* left;
	Node* right;

	Node(){ // Default constructor
		left = nullptr;
		right = nullptr;
	}

	Node(Course aCourse) : Node() { // Call the default constructor when calling the constructor
		course = aCourse;
	}
}
	private:
		Node* root;
		void addNode(Node* node, Course aCourse);
		void InOrderHelper(Node* node);
		void PreOrderHelper(Node* node);
		void PostOrderHelper(Node* node);
		void DeconstructorHelper(Node* node);
		Node* removeNode(Node* node, int courseNumber);
		int TreeSize;
		void vectorPrinter(vector<string> Vector);
	
	public:
		BST();
		virtual ~BST();
		void InOrder();
		void PostOrder();
		void PreOrder();
		void Insert(Course aCourse);
		void Remove (int courseNumber);
		void Size();
		Course Search(int courseNumber);
		void CreateFromFile(string file);
}

 /**
  * Adds a node with course to the tree
  *
  * @param Node* node to be referenced from
  * @param Course aCourse to be added
  */
void BST::addNode(Node* node, Course aCourse){
	if (node->course.courseNumber > aCourse.courseNumber){ // If the existing course number is greater than the one to be inserted
		if (node->left == nullptr) { // Left subtree has no lesser node
			node->left = new Node(aCourse); // Construct a new node and make it the left pointer of the current node
			this->TreeSize = this->TreeSize + 1; // Tree size has increased by one node
		}
		else { // Left not nullptr, exists
			addNode(node->left, aCourse); // Recurse leftward
		}
	}
	else { // Existing course number is less than the one to be inserted
		if (node->right == nullptr){ // Right subtree has no lesser node
			node->right = new Node(aCourse); // Construct a new node and make it the right pointer of the current node
			this->TreeSize = this->TreeSize + 1; // Tree size has increased by one node
		}
		else { // Right nmot nullptr, exists
			addNode(node->right, aCourse); // Recurse rightward
		}
	}
}

 /**
  * Passes root to the helper function to recursively traverse left, visit root, traverse right
  *
  * @param Node* node to be displayed
  */
void BST::InOrder(){
	this->InOrderHelper(root);
}

 /**
  * Recursively traverse left, visit root, traverse right
  *
  * @param Node* node to be displayed
  */
void BST::InOrderHelper(Node* node){
	if (node != nullptr) {
		InOrderHelper(node->left); // Recurse leftward to print all items before
		cout << node->course.courseNumber << ": " << node->course.courseTitle << " | ";
		vectorPrinter(node->course.coursePrerequisites);
		InOrderHelper(node->right); // Now recurse rightward now that we have printed all nodes to the left and the input node
	}
}

 /**
  * Passes root to the helper function to recursively visit root, traverse left, traverse right
  */
void BST::PreOrder(){
	this->PreOrderHelper(root);
}

 /**
  * Recursively visit root, traverse left, traverse right
  *
  * @param Node* node to be displayed
  */
void BST::PreOrderHelper(Node* node){
	if (node != nullptr){
		cout << node->course.courseNumber << ": " << node->course.courseTitle << " | ";
		vectorPrinter(node->course.coursePrerequisites);
		PreOrderHelper(node->left);
		PreOrderHelper(node->right);
	}
}

 /**
  * Passes root to the helper function to recursively traverse left, traverse right, visit root
  */
void BST::PostOrder(){
	this->PostOrderHelper(root);
}

 /**
  * Recursively traverse left, traverse right, visit root
  *
  * @param Node* node to be displayed
  */
void BST::PostOrderHelper(Node* node){
	if (node != nullptr){
		cout << node->course.courseNumber << ": " << node->course.courseTitle << " | ";
		vectorPrinter(node->course.coursePrerequisites);
		PostOrderHelper(node->left);
		PostOrderHelper(node->right);
	}
}

 /**
  * Default constructor
  */
BST::BST(){
	this->root = nullptr;
	this->TreeSize = 0;
}

 /**
  * Destructor
  */
virtual ~BST(){
	DeconstructorHelper(this->root);
}

 /**
  * Recursively deletes the nodes of a tree
  *
  * @param Node* node to be deleted
  */
void BST::DeconstructorHelper(Node* node){
	if(node != nullptr){
		DeconstructorHelper(node->left);
		DeconstructorHelper(node->right);
		delete node;
		node = nullptr;
		this->TreeSize = this->TreeSize - 1;
	}
}

 /**
  * Insert a course
  *
  * @param int Course to be inserted
  */
void BST::Insert(Course aCourse){
	if (root == nullptr){ // Root does not exist
		root = new Node(aCourse); // Make the new node root
		this->TreeSize = this->TreeSize + 1;
	}
	else {
		addNode(&(this->root), course) // Add by passing the root as reference since node was not specified
	}
}

 /**
  * Recursively remove a course
  * Passes node information to removeNode(Node* node, int courseNumber).
  *
  * @param int courseNumber to be removed
  */
void BST::Remove (int courseNumber){
	this->removeNode(root, courseNumber);
	cout << "Removed " + courseNumber << endl;
	this->TreeSize = this->TreeSize - 1;
	return;
}

 /**
  * Recursively remove a course from the tree
  *
  * @param Node* node to reference from
  * @param int Course to be removed
  */
Node* BinarySearchTree::removeNode(Node* node, int courseNumber) { 
	if (node == nullptr) {
		return nullptr;
	}

	if (node->course.courseNumber > course.courseNumber){ // If the existing course number is greater than the one to be removed
		node->left = removeNode(node->left, courseNumber); // Recurse down and replace the removed node
	}
	else if (node->course.courseNumber < course.courseNumber) { // Course for removal is larger, go right
		node->right = removeNode(node->right, courseNumber); // Recurse down and replace the removed node
	}
	else {
		if (node->left == nullptr && node->right == nullptr) { // leaf case
			delete node;
			node = nullptr; // Keep the pointer safe
			return nullptr;
		}
		else if (node->left != nullptr && node->right == nullptr) { // Right is null case ("Case 4")
			Node* temp = node;
			node = node->left;
			delete temp;
		}
		else if (node->left == nullptr && node->right != nullptr) { // Left is null case ("Case 3")
			Node* temp = node;
			node = node->right;
		}
		else { // Two children case ("Case 1")
			Node* temp = node->right;
			while (temp->left != nullptr) {  // Traverse left
				temp = temp->left;
			}
			node->course = temp->course;
			node->right = removeNode(node->right, temp->course.courseNumber); // Recursively remove successor since it was copied
		}
	}
	return node;
}

 /**
  * Searches a course from the tree
  *
  * @param int Course to be searched for
  */
Course BST::Search(int courseNumber){
	Node* currNode = this->root;

	while (currNode != nullptr) {
		// Compare the search courseNumber against the currently held courseNumber
		if (comparisonResult == matchFlag) { // Found the course
			return currNode->course; // Return the currently held course that matched
		}
		else if (comparisonResult < matchFlag) { // The check is less than what was checked against
			currNode = currNode->left; // Shift loop left
		}
		else { // current > courseNumber checked against
			currNode = currNode->right; // Shift loop right
		} // Continue looping
	} // Current is nullptr, match is not found

	Course course;
	return course;
}

 /**
  * Get the size of the current Binary Search Tree
  */
int BST::Size(){
	return this->TreeSize;
}

 /**
  * Prints a course's vector contents for prerequisites
  *
  * @param vector<string> Vector to be printed
  */
void BST::vectorPrinter(vector<string> Vector) {
	for (auto i: Vector){
		cout << i << ",";
	}
	cout << endl;
}

/**
  * Opens a file, reads its data, and parses each line and adds it to the Binary Search Tree
  *
  * @param string filename to be opened
  */
void BST::CreateFromFile(string file) {
	string line = ""; // Holds each line read from file
	verifyFile(file);
	
	// Initialize our variables for holding course information
	vector<string> prerequisites;
	string number;
	string title;
	
	ifstream infile(file); // Open the file

	while (getline(file, line)){ // Read each line from the file
		istringstream iss(line);
		string token;
		int i = 0;
		
		while (getline(iss, token, ',')){ // Parse the line by commas, token holds the values
			i++ // Increase the line count by 1
			
			if (i > 2){ // Add the prerequisites to the vector after the first two commas
				prerequisites.push_back(token);
			} else if (i == 1){ // The first line ex. "CSCI100"
				number = token;
			} else if (i == 2){ // The second line ex. "Introduction to Computer Science"
				title = token;
			}
		} // The line has been fully read
		Course course(number, title, prerequisites); // Create a course object with the parsed data
		Insert(course); // Insert that course object into the tree
	} // Continues looping until all lines have been parsed into course in BST

		

	infile.close(); // Close the file
}


//============================================================================
// Static methods
//============================================================================


 /**
  * Verifies file and data integrity and validity of a course document.
  *
  * @param string filename to be searched verified
  * 
  * Code based on ony of my own public repositories, Hold_to_Craft
  * https://github.com/Kubia-Beta/Hold_to_Craft
  */
void verifyFile(string &filename){
	string line = ""; // Comparison string, starts as empty
	ifstream infile(filename) // Open the file
	regex fileFormatting("C.*\d+,\s*[A-Za-z].*") // Catches C, then any characeters, then a digit, a comma, and then any letter
	try {
		if (!infile){ // could not open, failbit. We may not have access, or the file may not exist.
			throw runtime_error("File Access: Please verify the input file " + filename // Output what file went wrong with the error
			+ " exists and is not protected.");
		} else if (file.good == false){ // Other file operating issue
			throw runtime_error("Unknown File Access error on file " + filename + ".");
		}
		while(getline(infile, line)){ // While reading line by line
			int currLine = 1 // keep track of which line may throw an error for debugging
			
			// Begin verifying each line of the document:
			// Target format: "CSCI100,Introduction to Computer Science"
			if(line.find("CSC" != string::npos) || // Checks for common contents and compares them to "no position"
			  (line.find("Intro" != string::npos) || // If all three equal npos, then none were found
			  (line.find("100" != string::npos) ||{ // In short, we check for these three markers for valid formatting line by line
				
				// Components exist, is the formatting consistent with "CSCI100"
				if(line.substr(line.find("CSC") + 1).empty()) || // Look ahead by 1 position after finding this string.
				line.substr(line.find("Intro")+ 1).empty() || // If anything is read after these terms,
				line.substr(line.find("100")+ 1).empty() { // then the file must be following the correct format.
					// If no characters are found in the position after search strings, then:
					throw runtime_error("File Format: Error at line: " + currLine // Add the error line in the document to the error
					+ "Class names are of an incorrect format."
					+ " Expected type: CSCI100.");
				}
				
			} else if(regex_match(line, fileFormatting) == false){ // Uses a regex to find any class, if we do not find it:
				throw runtime_error("Internal File Structure: error at line " + currLine // Add the error line in the document to the error
				+ ". Class naming convention is incorrect and could not be read."
				+ "Expected type: CSCI100,Introduction to Computer Science");
			}
			
			++currLine; // Increase the line counter each time while() finishes a loop
		} // To get to this line, it must now be verified
		infile.close() // We are done verifying, close the file
		return
	}
	catch(){ // Something went wrong
		infile.close()
		cerr << "Error in file verification. Please check the console log."
		return
	}
}