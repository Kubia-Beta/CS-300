struct Course { // Structure to hold course information
	int courseNumber;
	string courseTitle;
	vector<string> coursePrerequisites;
	Course(){
		courseNumber = INT_MAX; // INT_MAX for debugging
	}
}

class BST {
	struct Node {
	Course course
	Node* left;
	Node* right;

	Node(){ // Default constructor
		left = nullptr;
		right = nullptr;
	}

	Node(Course aCourse) : Node() { // Call the default constructor when calling the constructor
		course = aCourse;
	}
}
	private:
		Node* root;
		void addNode(Node* node, Course course);
		void InOrderHelper(Node* node);
		void PreOrderHelper(Node* node);
		void PostOrderHelper(Node* node);
		Node* removeNode(Node* node, int courseNumber);
		int TreeSize;
	
	public:
		BST();
		virtual ~BST();
		void InOrder();
		void PostOrder();
		void PreOrder();
		void Insert(Course course);
		void remove (int courseNumber);
		Course Search(int courseNumber);
}

void BST::addNode(Node* node, Course course){
	if (node->course.courseNumber > course.courseNumber){ // If the existing course number is greater than the one to be inserted
		if (node->left == nullptr) { // Left subtree has no lesser node
			node->left = new Node(course); // Construct a new node and make it the left pointer of the current node
			this->TreeSize = this->TreeSize + 1; // Tree size has increased by one node
		}
		else { // Left not nullptr, exists
			addNode(node->left, course); // Recurse leftward
		}
	}
	else { // Existing course number is less than the one to be inserted
		if (node->right == nullptr){ // Right subtree has no lesser node
			node->right = new Node(course); // Construct a new node and make it the right pointer of the current node
			this->TreeSize = this->TreeSize + 1; // Tree size has increased by one node
		}
		else { // Right nmot nullptr, exists
			addNode(node->right, course); // Recurse rightward
		}
	}
}

void BST::InOrderHelper(Node* node){
	
}

void BST::PreOrderHelper(Node* node){
	
}

void BST::PostOrderHelper(Node* node){
	
}

BST::BST(){
	this->root = nullptr;
	this->TreeSize = 0;
}

virtual ~BST(){
	deleteTree(this->root);
}

void BST::InOrder(){
	
}

void BST::PostOrder(){
	
}

void BST::PreOrder(){
	
}

void BST::Insert(Course course){
	if (root == nullptr){ // Root does not exist
		root = new Node(course); // Make the new node root
	}
	else {
		addNode(&(this->root), course) // Add by passing the root as reference since node was not specified
	}
}

void BST::remove (int courseNumber){
	
}

Course BST::Search(int courseNumber){
	
}

int BST::Size(){
	return this->TreeSize;
}


// Code based on ony of my own public repositories, Hold_to_Craft
// https://github.com/Kubia-Beta/Hold_to_Craft
void verifyFile(string &filename){
	string line = ""; // Comparison string, starts as empty
	ifstream infile(filename) // Open the file
	regex fileFormatting("C.*\d+,\s*[A-Za-z].*") // Catches C, then any characeters, ends in a digit, comma, any letter
	try {
		if (!infile){ // could not open, failbit. We may not have access, or the file may not exist.
			throw runtime_error("File Access: Please verify the input file exists and is not protected")
		} else if (file.good == false){ // Other file operating issue
			throw runtime_error("Unknown File Access error")
		}
		while(getline(infile, line)){ // While reading line by line
			int i = 1 // Do these common contents exist, check with npos which will count
			if(line.find("CSC" != string::npos) || // Checks for common contents and compares them to "no position"
			  (line.find("Intro" != string::npos) || // If all three equal npos, then none were found
			  (line.find("100" != string::npos) ||{ // In short, we check for these three markers for valid formatting line by line
			  
				if(line.substr(line.find("CSC") + 1).empty()) || // Look ahead by 1 position after finding this string.
				line.substr(line.find("Intro")+ 1).empty() || // If anything is read after these terms,
				line.substr(line.find("100")+ 1).empty() { // then the file must be following the correct format.
					// If no characters are found after finding the search strings, then:
					throw runtime_error("File Format: Class names are of an incorrect format");
				}
			} else if(regex_match(line, fileFormatting) == false){ // Uses a regex to find any class, if we do not find it:
				throw runtime_error("Internal File Structure: error at line " + i
				+ ". Class naming convention is incorrect and could not be read."
				+ "Expected type: CSCI100,Introduction to Computer Science");
			}
			++i; // Increase the line counter each time while() finishes a loop
		} // To get to this line, it must now be verified
		infile.close() // We are done verifying, close the file
		return
	}
	catch(){ // Something went wrong
		infile.close()
		cerr << "Error in file verification. Please check the console log."
		return
	}
}

// Open the file, read the data, parse each line
void openAndReadFile(string file, Vector<Course> courses) {
	string line = "";
	verifyFile(file)
	
	ifstream infile(file)
	
	while (getline(infile, line)) {
		istringstream iss(line)
		string token
		vector<string> tokens
		
		while (getline(iss, token, ',')) {
			pushback(token)
		}
		
		for (token size) {
			coursePrerequisites.pushback(tokens[i])
		}
		Course course(number, title, prerequisites)
		courses.pushback(course)
	}
	
	infile.close()
}